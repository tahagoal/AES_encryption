#include <bits/stdc++.h>

typedef int word;
typedef short byte;

word cipher[4];

word message [4];
//{0x54776F20, 0x4F6E6520, 0x4E696E65, 0x2054776F};
//{0x876e46a6, 0xf24ce78c, 0x4d904ad8, 0x97ecc395};

word key [4];
//0x54686174, 0x73206d79, 0x204b756e, 0x67204675
//0x0f1571c9, 0x47d9e859, 0x0cb7add6, 0xaf7f6798

word gkeys[11][4];

byte sub_table[256] = {
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};


byte mult_2[256] = {
    0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
    0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
    0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
    0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
    0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
    0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
    0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
    0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
    0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
    0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
    0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
    0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
    0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
    0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
    0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
    0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};


word RC [10] = {0x01000000,0x02000000,0x04000000,0x08000000,0x10000000,
                0x20000000,0x40000000,0x80000000,0x1b000000,0x36000000};

using namespace std;


word g(word x, int r);

void add_round(word *M, word * K)
{
    for(int i = 0 ; i<4 ; i++)
    {
        word x = M[i]^K[i];
        cipher[i] = x;
    }
}

void sub_bytes(word *M)
{
    for(int i =0 ; i<4 ; i++)
    {
        byte x1 = M[i] >> 24 & 0xff ;
        x1 = sub_table[x1];
        byte x2 = M[i] >> 16 & 0xff ;
        x2 = sub_table[x2];
        byte x3 = M[i] >> 8 & 0xff ;
        x3 = sub_table[x3];
        byte x4 = M[i] >> 0 & 0xff ;
        x4 = sub_table[x4];
        cipher[i] = (x1 << 24)|(x2 << 16)|(x3 << 8)|x4 ;
    }
}
void shift_raws()
{
    word M[4];
    for(int i=0; i<4 ; i++)
        M[i]=cipher[i];
    cipher[0]= (((M[0])& 0xff000000) | ((M[1])& 0x00ff0000) | ((M[2])& 0x0000ff00) | ((M[3])& 0x000000ff));
    cipher[1]= (((M[1])& 0xff000000) | ((M[2])& 0x00ff0000) | ((M[3])& 0x0000ff00) | ((M[0])& 0x000000ff));
    cipher[2]= (((M[2])& 0xff000000) | ((M[3])& 0x00ff0000) | ((M[0])& 0x0000ff00) | ((M[1])& 0x000000ff));
    cipher[3]= (((M[3])& 0xff000000) | ((M[0])& 0x00ff0000) | ((M[1])& 0x0000ff00) | ((M[2])& 0x000000ff));
}

void mix_col(word *M)
{
    for(int i = 0 ; i<4 ;i++)
    {
        byte x1 = M[i] >> 24 & 0xff ;
        byte x2 = M[i] >> 16 & 0xff ;
        byte x3 = M[i] >> 8 & 0xff ;
        byte x4 = M[i] >> 0 & 0xff ;
        byte tmp = x1 ^ x2 ^ x3 ^ x4;
        byte y1 = x1 ^ tmp ^ mult_2[x1^x2];
        byte y2 = x2 ^ tmp ^ mult_2[x2^x3];
        byte y3 = x3 ^ tmp ^ mult_2[x3^x4];
        byte y4 = x4 ^ tmp ^ mult_2[x4^x1];
        cipher[i] = (y1 << 24)|(y2 << 16)|(y3 << 8)|y4 ;
    }
}


void key_exp()
{
    for(int i=1; i<11 ; i++)
    {
        word last = g(gkeys[i-1][3],i-1);
        gkeys[i][0]= gkeys[i-1][0] ^ last;
        gkeys[i][1]= gkeys[i][0] ^ gkeys[i-1][1];
        gkeys[i][2]= gkeys[i][1] ^ gkeys[i-1][2];
        gkeys[i][3]= gkeys[i][2] ^ gkeys[i-1][3];
    }
}

word g(word x, int r)
{
    byte x1 = x >> 24 & 0xff ;
    byte x2 = x >> 16 & 0xff ;
    byte x3 = x >> 8 & 0xff ;
    byte x4 = x >> 0 & 0xff ;
    x1 = sub_table[x1]; x2 = sub_table[x2]; x3= sub_table[x3]; x4 = sub_table[x4];
    byte tmp = x1 ;
    x1 = x2; x2=x3; x3 = x4; x4 = tmp;
    word w = (x1 << 24)|(x2 << 16)|(x3 << 8)|x4;
    return w ^ RC[r];
}

//mfrod 3ayz ytzabat de msh kowisa
int count_digits(word w)
{
    int counter=0;
    byte S = (w >> 0) &0xf ;
    if (S == 0)
        {counter ++ ;}
    S = (w >> 4) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 8) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 12) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 16) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 20) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 24) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    S = (w >> 28) &0xf ;
    if (S == 0)
        {counter ++;}
    else
        counter = 0;
    return counter;
}


void put(string S, int k, bool check)
{
    int x[8];
    for(int i=0;i<S.size();i++)
    {
        if(isdigit(S[i]))
            x[i]= S[i] - '0';
        else
            if(isupper(S[i]))
                x[i]= S[i] - 'A' + 10;
            else
                x[i]= S[i] - 'a' + 10;
    }
    int out = (x[0]<<28)|(x[1]<<24)|(x[2]<<20)|(x[3]<<16)|(x[4]<<12)|(x[5]<<8)|(x[6]<<4)|(x[7]<<0);
    if (check)
        message[k]=out;
    else
        key[k]=out;
}


int main()
{
    int n,m;
    string str;
    cin >> n;
    for(int inputs=0 ; inputs < n ; inputs ++)
    {
        cin >> str;
        put(str.substr (0,8),0, true);
        put(str.substr (8,8),1, true);
        put(str.substr (16,8),2,true);
        put(str.substr (24,8),3,true);
        cin >> str;
        put(str.substr (0,8),0, false);
        put(str.substr (8,8),1, false);
        put(str.substr (16,8),2,false);
        put(str.substr (24,8),3,false);

        for(int i=0 ; i<4 ;i++)
            gkeys[0][i] = key[i];
        key_exp();
        cin >> m ;
        for(int encrypt=0 ; encrypt < m ; encrypt++)
            {
                add_round(message, gkeys[0]);
                for(int i=1; i<10;i++)
                {
                    sub_bytes(cipher);
                    shift_raws();
                    mix_col(cipher);
                    add_round(cipher,gkeys[i]);

                }
                sub_bytes(cipher);
                shift_raws();
                add_round(cipher,gkeys[10]);
                if(m>1)
                    for(int j=0; j <4;j++)
                        message[j] = cipher[j];
            }

        for(int j=0; j <4;j++)
        {
            int c = count_digits(cipher[j]);
            for(int i=0 ;i<c ;i++)
                cout << "0";
            cout << hex << cipher[j];
        }
        cout << endl;
    }
}
